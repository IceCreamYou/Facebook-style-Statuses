<?php
// $Id$

/**
 * @file
 *   Allows users to have a "status."
 */

//=============
//DRUPAL HOOKS.
//=============

/**
 * Implementation of hook_help().
 */
function facebook_status_help($path, $arg) {
  if ($path == 'admin/help#facebook_status') {
    return t('Allows users the ability to have a Facebook-style "status." Please see the <a href="http://drupal.org/project/facebook_status" rel="nofollow">Project page</a> for more information.');
  }
}

/**
 * Implementation of hook_menu().
 */
function facebook_status_menu() {
  $items = array();
  $items['admin/settings/facebook_status'] = array(
    'title' => 'Facebook-style Statuses settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('facebook_status_admin'),
    'access arguments' => array('access administration pages'),
    'description' => 'Allows administrators to adjust certain display settings for Facebook-style Statuses.',
    'file' => 'facebook_status.admin.inc',
  );
  $items['admin/settings/facebook_status/general'] = array(
    'title' => 'General',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('access administration pages'),
    'weight' => -1,
  );
  $items['admin/settings/facebook_status/advanced'] = array(
    'title' => 'Advanced',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('facebook_status_admin_advanced'),
    'access arguments' => array('access administration pages'),
    'description' => 'Allows administrators to adjust certain display settings for Facebook-style Statuses.',
    'type' => MENU_LOCAL_TASK,
    'file' => 'facebook_status.admin.inc',
  );
  $items['share-status'] = array(
    'title' => 'Post to Status',
    'page callback' => 'theme',
    'page arguments' => array('facebook_status_form_display'),
    'access arguments' => array('edit own status'),
    'description' => 'Allows users to post items to their status from other sites.',
    'type' => 'MENU_SUGGESTED_ITEM',
  );
  $items['facebook_status/autocomplete'] = array(
    'title' => 'Facebook-style Statuses user autocomplete',
    'page callback' => '_facebook_status_user_autocomplete',
    'access arguments' => array('access administration pages'),
    'type' => MENU_CALLBACK,
  );
  $items['facebook_status/js/%user'] = array(
    'title' => 'Save status update form',
    'page callback' => 'facebook_status_save_js',
    'page arguments' => array(2),
    'access callback' => '_facebook_status_can_edit',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_block().
 */
function facebook_status_block($op = 'list', $delta = 0, $edit = NULL) {
  if ($op == 'list') {
    $block['facebook_status']['info'] = t('Facebook-style Statuses');
    return $block;
  }
  else if ($op == 'view' && $delta == 'facebook_status') {
    if (variable_get('facebook_status_special_user', '')) {
      $account = user_load(array('name' => variable_get('facebook_status_special_user', '')));
    }
    else {
      $account = facebook_status_choose_owner(FALSE);
    }
    $block['subject'] = t('Status');
    $block['content'] = theme('facebook_status_form_display', $account);
    return $block;
  }
  else if ($op == 'configure' && $delta == 'facebook_status') {
    $form['facebook_status'] = array(
      '#type' => 'fieldset',
      '#title' => t('Facebook-style Statuses Settings'),
      '#collapsible' => TRUE,
      '#weight' => -4,
      '#tree' => TRUE,
    );
    $form['facebook_status']['facebook_status_special_user'] = array(
      '#type' => 'textfield',
      '#title' => t('Special User'),
      '#default_value' => variable_get('facebook_status_special_user', ''),
      '#description' => t("If you enter a user's name in this field, the block will show only that user's status. Use this on single-user blog sites or for site announcements, for example."),
      '#element_validate' => array('facebook_status_alter_validate'),
      '#autocomplete_path' => 'user/autocomplete',
    );
    if (module_exists('twitter') && user_access('use global twitter account')) {
      $form['facebook_status']['facebook_status_twitter_special'] = array(
        '#type' => 'checkbox',
        '#title' => t('Post Special User statuses to the Global Twitter account'),
        '#description' => t('This option only applies if a user is entered in the Special User field above.'),
        '#default_value' => variable_get('facebook_status_twitter_special', 0),
      );
    }
    return $form;
  }
  else if ($op == 'save' && $delta == 'facebook_status') {
    variable_set('facebook_status_special_user', $edit['facebook_status']['facebook_status_special_user']);
    if ($edit['facebook_status']['facebook_status_twitter_special'] && module_exists('twitter')) {
      variable_set('facebook_status_twitter_special', $edit['facebook_status']['facebook_status_twitter_special']);
    }
  }
}

/**
 * Validate function for the Special User element in the form alter configuration.
 */
function facebook_status_alter_validate($element, &$form_state) {
  $name = $form_state['values']['facebook_status']['facebook_status_special_user'];
  if ($name) {
    $uid = db_result(db_query("SELECT uid FROM {users} WHERE name = '%s'", $name));
    if (!$uid) {
      form_set_error('facebook_status', t('You must use a valid username in the Special User field.'));
    }
  }
}

/**
 * Implementation of hook_perm().
 */
function facebook_status_perm() {
  return array('edit all statuses', 'edit own status', 'view all statuses');
}

/**
 * Implementation of hook_user().
 */
function facebook_status_user($op, &$edit, &$account, $category = NULL) {
  if ($op == 'delete') {
    //Remove abandoned statuses from the database on user account deletion.
    db_query('DELETE FROM {facebook_status} WHERE uid = %d', $account->uid);
  }
  if ($op == 'view' && !_facebook_status_exclude($account)) {
    if (!isset($account->content['facebook_status'])) {
      $account->content['facebook_status'] = array();
    }
    $account->content['facebook_status'] += array(
      '#type' => 'user_profile_category',
      '#attributes' => array('class' => 'facebook_status-profile-category'),
      '#weight' => -5,
      '#title' => t('Status'),
    );
    $size = variable_get('facebook_status_size_long', 40);
    $account->content['facebook_status']['status'] = array(
      '#type' => 'user_profile_item',
      '#title' => '',
      '#value' => theme('facebook_status_form_display', $account, $size),
      '#attributes' => array('class' => 'facebook_status profile'),
    );
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 * No need to check permissions since the form is already restricted.
 */
function facebook_status_form_twitter_account_list_form_alter(&$form, &$form_state) {
  $result = db_query("SELECT screen_name FROM {twitter_user} WHERE uid = %d", arg(1));
  $options = array(0 => t('None'));
  while ($option = db_fetch_array($result)) {
    $options[$option['screen_name']] = $option['screen_name'];
  }
  $account = user_load(array('uid' => arg(1)));
  $data = unserialize($account->data);

  if (!empty($options) && variable_get('facebook_status_twitter', 1)) {
    $form_state['#account'] = $account;
    $form['facebook_status_twitter'] = array(
      '#type' => 'select',
      '#title' => t('Choose an account to which status updates can be posted'),
      '#description' => t('If you choose a Twitter account here, you will be given the option to post your status updates to Twitter on the status update form.'),
      '#default_value' => $data['facebook_status_twitter'],
      '#options' => $options,
      '#weight' => -1,
    );
    $form['#submit'][] = 'facebook_status_twitter_submit';
  }
}

/**
 * Submit function for the Twitter account form alter.
 */
function facebook_status_twitter_submit($form, &$form_state) {
  $account = $form_state['#account'];
  if ($account) {
    user_save($account, array('facebook_status_twitter' => $form_state['values']['facebook_status_twitter']), 'twitter');
  }
}

/**
 * Implementation of hook_theme().
 */
function facebook_status_theme($existing, $type, $theme, $path) {
  return array(
    'facebook_status_item' => array(
      'arguments' => array(
        'account' => NULL,
        'status' => NULL,
        'linked' => TRUE,
      ),
    ),
    'facebook_status_form_display' => array(
      'arguments' => array(
        'account' => FALSE,
      ),
    ),
    'facebook_status_time' => array(
      'arguments' => array(
        'status_time' => time(),
      ),
    ),
    'facebook_status_flag_create' => array(
      'arguments' => array(
        'sid' => FALSE,
      ),
    ),
  );
}

//================
//THEME FUNCTIONS.
//================

/**
 * Formats a status. Does not check to make sure the status belongs to the
 * relevant user if a status is passed in.
 *
 * @param $account
 *   The $user object of the user who owns the status.
 * @param $status
 *   A full status object. If not passed, gets the last status for the relevant
 *   user automatically. If there is none, uses a default message.
 * @param $linked
 *   If TRUE, themes the username; this usually makes it a link.
 *   If FALSE, uses the unthemed (and thus unlinked) username so that the result
 *   can be placed within linked text.
 * @return
 *   HTML to display the themed status or FALSE if the current user does not
 *   have permission to view the status.
 */
function theme_facebook_status_item($account, $status = FALSE, $linked = TRUE) {
  global $user;
  if (!user_access('view all statuses', $user) && $user->uid != $account->uid) {
    return FALSE;
  }
  $name = theme('username', $account);
  if (!$linked) {
    $name = check_plain($account->name);
  }
  if (!$status) {
    $status_orig = facebook_status_get_status($account->uid, 1, -1, FALSE);
    $status = $status_orig[0];
  }
  if (!$status->status) {
    if (variable_get('facebook_status_concat', 1) == 0) {
      $status->status = t('!user does not have a status.', array('!user' => $name));
    }
    else {
      $status->status = t('does not have a status.');
    }
  }
  $time = '<span class="facebook_status-time">'. theme('facebook_status_time', $status->status_time) .'</span>';
  //We trim() to remove the extra space on the end if there are no flags.
  if (variable_get('facebook_status_concat', 1)) {
    if (_facebook_status_possessive($status->status)) {
      $output = t('!user@status !time', array('!user' => $name, '@status' => $status->status, '!time' => $time));
    }
    else {
      $output = t('!user @status !time', array('!user' => $name, '@status' => $status->status, '!time' => $time));
    }
  }
  else {
    $output = t('@fbsstatus !time', array('!user' => $name, '@fbsstatus' => $status->status, '!time' => $time));
  }
  //Invokes hook_facebook_status_render($status_owner_object, &$status, $linked = TRUE).
  //In general, if $linked is FALSE then this is being used on the status update form.
  module_invoke_all('facebook_status_render', $account, $output, $linked);
  return $output;
}

/**
 * Returns the status update form.
 *
 * @param $account
 *   The user whose status form should be displayed, or FALSE to have the module
 *   detect the relevant user automatically according to the settings.
 * @param $size
 *   The size of the status update textfield, or FALSE to use the setting.
 * @return
 *   HTML to display the status update form or FALSE if the user cannot have a
 *   status.
 */
function theme_facebook_status_form_display($account = FALSE, $size = FALSE) {
  if ($account === FALSE) {
    $account = facebook_status_choose_owner(FALSE);
  }
  $can_edit = _facebook_status_can_edit($account);
  if ($can_edit) {
    $excluded = _facebook_status_exclude($account);
    if ($excluded) {
      return FALSE;
    }
    return '<div id="facebook_status_update" class="clear-block">'. drupal_get_form('_facebook_status_status', $account, $size) .'</div>';
  }
  else {
    return theme('facebook_status_item', $account);
  }
}

/**
 * Returns a formatted string showing the time the status was submitted.
 *
 * @param $status_time
 *   The Unix timestamp for when the relevant status was updated.
 * @return
 *   If the status was submitted within the last 3 days, returns a "time ago"
 *   date. If not, returns a normal (small) date. If zero, returns FALSE.
 */
function theme_facebook_status_time($status_time) {
  if (!$status_time) {
    return FALSE;
  }
  if (time() - $status_time < 60) {
    return t('a moment ago');
  }
  else if (time() - $status_time < 60 * 60 * 24 * 3) {
    return t('!time ago', array('!time' => format_interval(time() - $status_time, 1)));
  }
  else {
    return format_date($status_time, 'small');
  }
}


/**
 * Builds flag links to display for statuses.
 *
 * @param $sid
 *   The Status ID of the status for which flags should be built.
 * @return
 *   Themed flag links.
 */
function theme_facebook_status_flag_create($sid) {
  if (!module_exists('flag')) {
    return '';
  }
  $links = array();
  $result = db_query("SELECT name FROM {flags} WHERE content_type = 'facebook_status'");
  while ($name = db_fetch_object($result)) {
    $links[] = flag_create_link($name->name, $sid);
  }
  return implode(' ', $links);
}

//====
//API.
//====

/**
 * Returns a status or statuses for a single user.
 *
 * @param $uid
 *   The User ID of the user whose status will be returned.
 *   If $uid evaluates to FALSE, the current user is assumed.
 * @param $count
 *   The maximum number of statuses to return.
 *   If zero, all relevant statuses are returned ($instance still matters).
 * @param $instance
 *   Allows getting statuses that are older than the most recent status.
 *   If positive, gets statuses after the timestamp $instance.
 *   If negative, gets the $instance-th most recent status (and newer ones).
 *   If negative and there are fewer than abs($instance) statuses available,
 *   the counting starts with the first one.
 *   If zero, gets $count statuses starting with the first one.
 * @param $exclude_blank
 *   If TRUE, blank statuses will not be included.  If FALSE, they will be.
 * @return
 *   An array of status objects.
 *   If the user has no statuses, or may not have statuses, returns FALSE.
 */
function facebook_status_get_status($uid = 0, $count = 1, $instance = -1, $exclude_blank = TRUE) {
  $excluded = _facebook_status_exclude(user_load(array('uid' => $uid)));
  if ($excluded) {
    return FALSE;
  }
  if (!$uid) {
    global $user;
    $uid = $user->uid;
  }
  //Greater than or equal to zero.  This means $instance = 0 can retrieve all statuses starting with the first one.
  //Note that the above is true even though we exclude statuses where status_time == 0 because only blank statuses have status_time == 0.
  if ($instance >= 0) {
    if ($count == 0) {
      if ($exclude_blank) {
        $result = db_query("SELECT sid FROM {facebook_status} WHERE uid = %d AND status_time > %d AND status_time <> 0 ORDER BY sid DESC", $uid, $instance);
      }
      else {
        $result = db_query("SELECT sid FROM {facebook_status} WHERE uid = %d AND status_time > %d ORDER BY sid DESC", $uid, $instance);
      }
    }
    else {
      if ($exclude_blank) {
        $result = db_query_range("SELECT sid FROM {facebook_status} WHERE uid = %d AND status_time > %d AND status_time <> 0 ORDER BY sid DESC", $uid, $instance, 0, $count);
      }
      else {
        $result = db_query_range("SELECT sid FROM {facebook_status} WHERE uid = %d AND status_time > %d ORDER BY sid DESC", $uid, $instance, 0, $count);
      }
    }
  }
  else {
    $total = facebook_status_has_status($uid);
    //If $count == 0 we want to get all relevant statuses, so set $count to the total number of statuses for this user so they all get included.
    if ($count == 0) {
      $count = $total;
    }
    //Offset actually starts at zero in SQL, but $instance starts at (negative) 1.
    $offset = abs($instance) - 1;
    //If there are fewer than abs($instance) statuses available, just start with the first one.
    if ($total + $instance < 0) {
      $offset = 0;
    }
    if ($exclude_blank) {
      $result = db_query_range("SELECT sid FROM {facebook_status} WHERE uid = %d AND status_time <> 0 ORDER BY sid DESC", $uid, $offset, $count);
    }
    else {
      $result = db_query_range("SELECT sid FROM {facebook_status} WHERE uid = %d ORDER BY sid DESC", $uid, $offset, $count);
    }
  }
  $statuses = array();
  while ($sid = db_fetch_array($result)) {
    $status = facebook_status_load($sid);
    if (trim($status->status)) {
      $statuses[] = $status;
    }
  }
  if (!empty($statuses)) {
    return $statuses;
  }
  return FALSE;
}

/**
 * Returns statuses for multiple users.
 * Assumes blank statuses shouldn't be returned.
 *
 * @param $uids
 *   An array of User IDs for users whose statuses will be returned. If empty,
 *   all users' statuses will be considered.
 * @param $total
 *   The maximum number of statuses to return.
 *   If zero, all relevant statuses are returned (but $count still matters).
 * @param $count
 *   The maximum number of statuses to include for each user.
 *   If zero, all relevant statuses are returned for each user.
 * @return
 *   An array of status objects.
 */
function facebook_status_get_statuses($uids = array(), $total = 0, $count = 1) {
  $statuses = array();
  if (empty($uids)) {
    //Handle separately for speed.
    if ($count == 1) {
      if ($total == 0) {
        $result = db_query("SELECT sid, uid FROM (SELECT sid, uid FROM {facebook_status} WHERE status_time <> 0 ORDER BY sid DESC) x GROUP BY uid ORDER BY sid DESC");
      }
      else {
        $result = db_query_range("SELECT sid, uid FROM (SELECT sid, uid FROM {facebook_status} WHERE status_time <> 0 ORDER BY sid DESC) x GROUP BY uid ORDER BY sid DESC", 0, $total);
      }
    }
    else if ($count == 0) {
      if ($total == 0) {
        $result = db_query("SELECT sid, uid FROM {facebook_status} WHERE status_time <> 0 ORDER BY sid DESC");
      }
      else {
        $result = db_query_range("SELECT sid, uid FROM {facebook_status} WHERE status_time <> 0 ORDER BY sid DESC", 0, $total);
      }
    }
    else {
      //Get all users who may possibly have posted the relevant statuses and pass them back in. The results will be limited later.
      $result = db_query_range("SELECT uid FROM (SELECT uid FROM {facebook_status} WHERE status_time <> 0 ORDER BY sid DESC) x GROUP BY uid ORDER BY sid DESC", 0, $total);
      $uids = array();
      while ($uid = db_fetch_array($result)) {
        if ($uid['uid']) {
          $uids[] = $uid['uid'];
        }
      }
      facebook_status_get_statuses($uids, $total, $count);
      return;
    }
    while ($sid = db_fetch_array($result)) {
      if ($sid['sid'] && !_facebook_status_exclude(user_load(array('uid' => $sid['uid'])))) {
        $status = facebook_status_load($sid['sid']);
        $statuses[$status->sid] = $status;
      }
    }
    krsort($statuses);
  }
  else {
    foreach ($uids as $uid) {
      $status_orig = facebook_status_get_status($uid, $count);
      $status = $status_orig[0];
      if ($status && trim($status->status)) {
        $statuses[$status->sid] = $status;
      }
    }
    krsort($statuses);
    if (!empty($statuses) && $total != 0) {
      $statuses = array_slice($statuses, 0, $total);
    }
  }
  //array_values() indexes numerically.
  return array_values($statuses);
}

/**
 * Determines whether a user has statuses.
 *
 * @param $uid
 *   The User ID of the user whose number of statuses will be looked up.
 *   If $uid evaluates to FALSE, the current user will be assumed.
 * @return
 *   The number of statuses of the relevant user.
 */
function facebook_status_has_status($uid = FALSE) {
  if (!$uid) {
    global $user;
    $uid = $user->uid;
  }
  return db_result(db_query("SELECT COUNT(sid) FROM {facebook_status} WHERE uid = %d", $uid));
}

/**
 * Load a status object.
 *
 * @param $sid
 *   The Status ID.
 * @return
 *   A full status object containing sid, status, status_time, and uid.
 */
function facebook_status_load($sid) {
  return db_fetch_object(db_query("SELECT * FROM {facebook_status} WHERE sid = %d", $sid));
}

/**
 * Delete a status from the database. Not exposed in the UI anywhere.
 *
 * @param $sid
 *   The Status ID or a status object.
 */
function facebook_status_delete_status($sid) {
  if (is_object($sid)) {
    $sid = $sid->sid;
  }
  //Rules integration.
  if (module_exists('rules')) {
    rules_invoke_event('facebook_status_delete', $sid);
  }
  //Invokes hook_facebook_status_delete($sid).
  module_invoke_all('facebook_status_delete', $sid);
  db_query("DELETE FROM {facebook_status} WHERE sid = %d", $sid);
}

/**
 * Saves a status into the database.
 *
 * @param $account
 *   The $user object for the user whose status will be saved.
 * @param $new_status
 *   The status text to be saved.
 */
function facebook_status_save_status($account = FALSE, $new_status = '') {
  if (!$account) {
    $account = facebook_status_choose_owner();
  }
  global $user;
  //If the user clears the status, set the time to zero so the new, blank status will not show up as new in lists.
  $time = time();
  if ($new_status === '') {
    $time = 0;
  }
  //Choose "your" or "user's" depending on whether the editing user is the owner of the status.
  $your = t('Your');
  if ($user->uid != $account->uid) {
    $your = t("!user's", array('!user' => theme('username', $account)));
  }
  //Pretend to have set a new status if the submitted status is exactly the same as the old one.
  $status = facebook_status_get_status($account->uid);
  if ($new_status != $status[0]->status && $account->uid) {
    //If a new status is submitted within 12 seconds of the old one, we assume the user didn't mean to post the first one, and write over it.
    if (time() - $status[0]->status_time < 12) {
      db_query("UPDATE {facebook_status} SET status = '%s', status_time = %d WHERE uid = %d ORDER BY sid DESC LIMIT 1", $new_status, $time, $account->uid);
    }
    else {
      $object = (object) array('status' => $new_status, 'status_time' => $time, 'uid' => $account->uid);
      drupal_write_record('facebook_status', $object);
    }
    //Invokes hook_facebook_status_save($status_owner_object, &$status).
    module_invoke_all('facebook_status_save', $account, $new_status);
  }
  //Trigger integration.
  if (module_exists('trigger')) {
    module_invoke_all('facebook_status', 'submitted', $user);
  }
  //Activity integration.
  facebook_status_activity($account, $new_status);
  //Rules integration.
  if (module_exists('rules')) {
    rules_invoke_event('facebook_status_update', $account, $new_status);
  }
  //Twitter integration.
  if (module_exists('twitter') && user_access('use global twitter account') && variable_get('facebook_status_twitter_special', 0)) {
    twitter_set_status(variable_get('twitter_global_name', NULL), variable_get('twitter_global_password', NULL), $new_status);
  }

  //A message to show to the user if necessary.
  return t('!possessive status has been updated.', array('!possessive' => $your));
}

/**
 * Determines the user whose status should be shown.
 *
 * @param $legacy
 *   An array specifying which realms to treat with legacy behavior.  If
 *   $legacy['user'] == TRUE, then on profile pages the owner of the profile
 *   will be returned.  If $legacy['node'] == TRUE, then on nodes the author of
 *   the node will be returned.  Everywhere else, or if $legacy has no value in
 *   the 'user' or 'node' keys, the current user will be returned. If $legacy is
 *   FALSE, the module's settings will be applied.
 * @return
 *   The $user object for the user whose status should be shown.
 */
function facebook_status_choose_owner($legacy = array()) {
  if ($legacy === FALSE) {
    $legacy = variable_get('facebook_status_legacy', array('user' => 'user'));
  }
  if ($legacy['user'] && arg(0) == 'user' && is_numeric(arg(1))) {
    return user_load(array('uid' => arg(1)));
  }
  else if ($legacy['node'] && arg(0) == 'node' && is_numeric(arg(1))) {
    $node = menu_get_object();
    return user_load(array('uid' => $node->uid));
  }
  else {
    global $user;
    return $user;
  }
}

//=================
//HELPER FUNCTIONS.
//=================

/**
 * Determines if the current user can edit the relevant status.
 *
 * @param $author
 *   The $user object for the author of the status.  If FALSE, determine
 *   the author automatically.
 * @return
 *   TRUE if the current user can edit the status; FALSE otherwise.
 */
function _facebook_status_can_edit($author = FALSE) {
  global $user;
  if (!$author) {
    $author = facebook_status_choose_owner(FALSE);
  }
  if (($user->uid == $author->uid && user_access('edit own status')) || user_access('edit all statuses')) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Determines whether the relevant user can have a status.
 *
 * @param $account
 *   The $user object of the user to examine. If FALSE, the current user is
 *   assumed.
 * @return
 *   FALSE if the user is allowed to have a status; TRUE otherwise.
 */
function _facebook_status_exclude($account) {
  if (!$account) {
    global $user;
    $account = $user;
  }
  //This variable should get saved so that this splits it exactly into the names without needing to trim().
  $names = explode(', ', variable_get('facebook_status_exclude', ''));
  if (in_array($account->name, $names)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Determines if a status starts with the English possessive apostrophe-S.
 *
 * @param $status
 *   The relevant status text.
 * @return
 *   TRUE if the status is possessive; FALSE otherwise.
 */
function _facebook_status_possessive($status) {
  //Don't use this function with Facebook Mode because there's nothing to concatenate with.
  if (!variable_get('facebook_status_concat', 1)) {
    return FALSE;
  }
  $language = user_preferred_language($account);
  $language = $language->language;
  $string = drupal_substr($status, 0, 3);
  if ($language == 'en' && $string == "'s ") {
    return TRUE;
  }
  return FALSE;
}

/**
 * Autocompletes multiple-username textfields.
 * Some awkwardness exists if a user has quotes or commas in their username.
 * Adapted from taxonomy.module.
 *
 * @param $string
 *   The list of names.
 */
function _facebook_status_user_autocomplete($string = '') {
  $array = drupal_explode_tags($string);
  //The user enters a comma-separated list of names. We only autocomplete the last name.
  $search = trim(array_pop($array));
  $matches = array();
  if ($search != '') {
    $result = db_query_range("SELECT DISTINCT(name) FROM {users}
      WHERE status <> 0 AND uid <> 0 AND LOWER(name) LIKE LOWER('%s%%')
      ORDER BY name ASC", $search, 0, 10);
    $prefix = count($array) ? implode(', ', $array) .', ' : '';
    while ($user = db_fetch_object($result)) {
      $name = $user->name;
      //Commas and quotes in terms are special cases, so encode them.
      //Use strpos() to check if they exist first since str_replace() is costly.
      if (strpos($user->name, ',') !== FALSE || strpos($user->name, '"') !== FALSE) {
        $name = '"'. str_replace('"', '""', $user->name) .'"';
      }
      $matches[$prefix . $name] = check_plain($user->name);
    }
  }
  drupal_json($matches);
}

//======
//FORMS.
//======

/**
 * The status form.
 *
 * @param $account
 *   The $user object for the user whose status will be shown.
 * @param $size
 *   The size of the status update textfield, or FALSE to use the setting.
 * @return
 *   A $form array.
 */
function _facebook_status_status(&$form_state, $account, $size = FALSE) {
  if (!$size) {
    $size = variable_get('facebook_status_size', 32);
    if (arg(0) == 'share-status') {
      $size = variable_get('facebook_status_size_long', 40);
    }
  }
  $maxlength = variable_get('facebook_status_length', 192);
  //Because this text will appear exactly as-is in the textfield, we can't use a full check_plain() or filter_xss().
  //We also translate a blank string so that the default text can be in different languages without having the restriction of being preset.
  $default = str_replace('"', '', t('@fbssdefault', array('@fbssdefault' => '')));

  if (variable_get('facebook_status_concat', 1)) {
    $prefix = '<span class="facebook_status_hide">'. t('!fbss_prefix_name ', array('!fbss_prefix_name' => theme('username', $account))) .'&nbsp;</span>';
  }
  else {
    $prefix = '';
  }
  $status = facebook_status_get_status($account->uid, 1, -1, FALSE);
  $status = $status[0];
  if ($status->status_time) {
    $default = $status->status;
  }
  //An awkward hack that makes the JS status update callback aware that we came from a page where we don't want to linkify the status text.
  if (arg(0) != 'facebook_status' && arg(1) != 'js') {
    $_SESSION['#fbss-no-linkify'] = $_GET['q'];
  }
  if (arg(0) == 'share-status') {
    $default = str_replace('"', '', $_GET['s']);
    //Keep the default value from clearing when the user clicks on the form.
    $form_state['#js_exists'] = TRUE;
  }

  $path = drupal_get_path('module', 'facebook_status');
  $slider = theme('facebook_status_item', $account, FALSE, FALSE);
  //When the status update form is present in the page content, there can be two status forms on user profiles.
  //That will cause problems with the JavaScript, so we simply don't add it to the page.
  if (variable_get('facebook_status_slide', 1) && arg(0) != 'share-status') {
    if (!$form_state['#js_exists']) {
      drupal_add_js($path .'/facebook_status.js');
    }
    if ($_SESSION['#fbss-no-linkify'] != 'share-status') {
      $slider = '<a href="#status" name="status" class="facebook_status_slide">'. $slider .'</a>';
    }
  }
  if (!$form_state['#css_exists']) {
    drupal_add_css($path .'/facebook_status.css');
  }
  $form['slider'] = array('#prefix' => '<span id="facebook_status_replace">', '#value' => $slider);
  $form['status'] = array(
    '#type' => 'textfield',
    '#field_prefix' => $prefix,
    '#size' => $size,
    '#maxlength' => $maxlength,
    '#default_value' => $default,
    '#attributes' => array('class' => 'facebook_status_hide'),
    '#suffix' => '</span>',
  );
  $form['fbss-submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#submit' => array('_facebook_status_status_submit'),
    '#attributes' => array('class' => 'facebook_status_hide'),
  );
  $form['fbss-submit']['#ahah'] = array(
    'path' => 'facebook_status/js/'. $account->uid .'/'. $size,
    'wrapper' => 'facebook_status_replace',
    'effect' => 'fade',
    'method' => 'replace',
  );
  $data = unserialize($account->data);
  if (module_exists('twitter') && $data['facebook_status_twitter'] && $account->uid == $GLOBALS['user']->uid && variable_get('facebook_status_twitter', 1)) {
    $form['twitter'] = array(
      '#type' => 'checkbox',
      '#title' => t('Post to Twitter'),
      //'#attributes' => array('class' => 'facebook_status_hide'),
    );
  }
  $form_state['#account'] = $account;
  $_SESSION['#fbss-uid'] = $account->uid;
  //Hack to remove slider text if necessary.
  if (variable_get('facebook_status_hide_status', 0)) {
    $form['slider']['#value'] = '';
  }
  //@todo: This is bad. It should be in the CSS but that doesn't seem to be working.
  $form['#attributes'] = array('style' => 'margin-bottom: 0;');
  return $form;
}

/**
 * Submit function for the status update form.
 */
function _facebook_status_status_submit($form, &$form_state) {
  $account = $form_state['#account'];
  if (!$account->uid) {
    $account = user_load(array('uid' => $_SESSION['#fbss-uid']));
  }
  $new_status = trim($form_state['values']['status']);
  if ($form_state['values']['twitter']) {
    facebook_status_twitter($account, $new_status);
  }

  $message = facebook_status_save_status($account, $new_status);

  if (!$form_state['#js_exists']) {
    drupal_set_message($message);
  }
}

/**
 * Saves statuses via AHAH.
 */
function facebook_status_save_js() {
  $form_state = array('storage' => NULL, 'submitted' => FALSE);
  $form_build_id = $_POST['form_build_id'];
  $form = form_get_cache($form_build_id, $form_state);
  $form_state['post'] = $form['#post'] = $_POST;
  $form['#programmed'] = $form['#redirect'] = FALSE;
  //Custom parameters that let us know whether the AHAH has already been run.
  $form_state['#js_exists'] = TRUE;
  $form_state['#css_exists'] = TRUE;

  $account = user_load(array('uid' => arg(2)));
  $size = arg(3);
  if (!is_numeric($size) || round($size) != $size || $size < 1) {
    $size = variable_get('facebook_status_size', 32);
  }

  //Oddly, $args is not always an array.
  $form_id = '_facebook_status_status';
  $args = $form['#parameters'];
  if (is_array($args)) {
    $form_id = array_shift($args);
  }

  //Get HTML for the replacement form.
  drupal_process_form($form_id, $form, $form_state);
  $form = drupal_rebuild_form($form_id, $form_state, array('_facebook_status_status', $account, $size));
  $new_form['slider'] = $form['slider'];
  $new_form['status'] = $form['status'];
  //Prevent duplicate wrappers.
  unset($form['slider']['#prefix']);
  unset($form['status']['#suffix']);
  $output = theme('status_messages') . drupal_render_form($form_id, $new_form);

  //Return the results.
  drupal_json(array('status' => TRUE, 'data' => $output));
}

//====================
//TRIGGER INTEGRATION.
//====================

/**
 * Note that Actions integration is not present, even though Triggers
 * integration is. That's because there's really no easily conceivable action
 * that Facebook-style Statuses should define except to display a message to the
 * user. However, that action is already available, just through the UI for all
 * hooks. Use the triggerunlock module, which lets you use any action with any
 * hook, to access the display message action with facebook_status triggers.
 * Of course, you can also write your own.
 */

/**
 * Implementation of hook_hook_info().
 */
function facebook_status_hook_info() {
  return array(
    'Facebook-style Statuses' => array(
      'facebook_status' => array(
        'submitted' => array(
          'runs when' => t('The status update form has been submitted.'),
        ),
      ),
    ),
  );
}

/**
 * Implementation of hook_facebook_status().
 */
function facebook_status_facebook_status($op, $user) {
  if (!in_array($op, array('submitted'))) {
    return;
  }
  $aids = _trigger_get_hook_aids('facebook_status', $op);
  $context = array(
    'hook' => 'facebook_status',
    'op' => $op,
    'user' => $user,
  );
  actions_do(array_keys($aids), $user, $context);
}

//===============================
//ACTIVITY AND TOKEN INTEGRATION.
//===============================

/**
 * Implementation of hook_activity_info().
 */
function facebook_status_activity_info() {
  $token_types['facebook_status'] = t('Facebook-style Statuses');
  //Note that we do not define the role of the user who updated the status. That's because it would usually make for very confused messages.
  return array(
    'ops' => array('update' => t('Submit Status Update')),
    'types' => $token_types,
    'roles' => array(
      'owner' => array(
        '#name' => t('Owner'),
        '#description' => t('The user who owns the status.'),
        '#default' => 'You have an [operation]d status.',
      ),
      'all' => array(
        '#name' => t('All'),
        '#description' => t('Everyone who can see status updates.'),
        '#default' => '[owner] has an [operation]d status.',
      ),
    ),
  );
}

/** 
 * Implementation of hook_activityapi().
 * I have no idea why this is actually necessary.
 */
function facebook_status_activityapi(&$activity, $op) {
  if ($op == 'load') {
    if ($activity['data']['module'] == 'facebook_status' && user_access('view all statuses')) {
      $activity = array();
    }
  }
}

/**
 * Implementation of hook_token_list().
 */
function facebook_status_token_list($type = 'all') {
  if ($type == 'facebook_status') {
    $tokens['facebook_status'] = array(
      'operation' => t('The operation that took place. Always "update."'),
      'owner' => t('The owner of the updated status.'),
      'status' => t('The new status.'),
      'status-time' => t('The time the status was submittted.'),
    );
    return $tokens;
  }
}

/**
 * Implementation of hook_token_values().
 */
function facebook_status_token_values($type, $data = NULL, $options = array()) {
  if ($type == 'facebook_status' && !empty($data)) {
    $status_time = $data['status_time'];
    $data['status-time'] = theme('facebook_status_time', $status_time);
    return $data;
  }
}

/**
 * Handles recording activity messages.
 *
 * @param $account
 *   The $user object of the owner of the status.
 * @param $status
 *   The status object containing the status to record. Requires at least the
 *   status and status_time.
 */
function facebook_status_activity($account, $status) {
  if (!module_exists('activity')) {
    return FALSE;
  }
  //Privacy setting check.
  if (activity_user_privacy_optout($account)) {
    return FALSE;
  }
  $data = array(
    'operation' => 'update',
    'owner' => theme('username', $account),
    'status' => check_plain($status->status),
    'status_time' => $status->status_time,
  );
  $target_users_roles = array(
    ACTIVITY_ALL => 'all',
    $account->uid => 'owner'
  );
  activity_insert($account->uid, 'facebook_status', 'status', 'update', $data, $target_users_roles);
}

//==================
//VIEWS INTEGRATION.
//==================

/**
 * Implementation of hook_views_api().
 */
function facebook_status_views_api() {
  return array('api' => 2);
}

//====================
//Twitter Integration.
//====================

/**
 * Posts a status to Twitter.
 */
function facebook_status_twitter($account, $status) {
  if (!module_exists('twitter')) {
    return;
  }
  $twitter_accounts = twitter_get_user_accounts($account->uid);
  $data = unserialize($account->data);
  $twitter_account = $twitter_accounts[$data['facebook_status_twitter']];
  module_load_include('inc', 'twitter');
  twitter_set_status($twitter_account['screen_name'], $twitter_account['password'], $status);
}

//=================
//FLAG INTEGRATION.
//=================

/**
 * Implementation of hook_flag_definitions().
 */
function facebook_status_flag_definitions() {
  return array(
    'facebook_status' => array(
      'title' => 'Facebook-style Statuses',
      'description' => t('Statuses are short textual messages users use to express themselves.'),
      'handler' => 'facebook_status_flag',
    ),
  );
}

/**
 * Implementation of hook_flag().
 */
function facebook_status_flag($flag_status, $flag_object, $flagged_item_id, $flagger) {
  if ($flag_object->name == 'facebook_status_delete' && $flag_object->content_type == 'facebook_status') {
    facebook_status_delete_status($flagged_item_id);
  }
}

/**
 * Implementation of hook_flag_default_flags().
 */
function facebook_status_flag_default_flags() {
  $flags = array();
  $flags[] = array(
    'content_type' => 'facebook_status',
    'name' => 'like',
    'title' => t('Like'),
    'roles' => array('2'),
    'global' => FALSE,
    'types' => array('page'),
    'flag_short' => t('Like'),
    'flag_long' => '',
    'flag_message' => '',
    'unflag_short' => t('Un-like'),
    'unflag_long' => '',
    'unflag_message' => '',
    'show_on_page' => FALSE,
    'show_on_teaser' => FALSE,
    'show_on_form' => FALSE,
    'status' => TRUE,
    'locked' => array('name', 'global', 'types', 'show_on_page', 'show_on_teaser', 'show_on_form', 'status'),
  );
  $flags[] = array(
    'content_type' => 'facebook_status',
    'name' => 'facebook_status_delete',
    'title' => t('Delete'),
    'roles' => array(),
    'global' => TRUE,
    'types' => array('page'),
    'flag_short' => t('Delete'),
    'flag_long' => '',
    'flag_confirmation' => t('Are you sure you want to permanently delete this status?'),
    'flag_message' => '',
    'unflag_short' => t('Un-delete'),
    'unflag_long' => '',
    'unflag_confirmation' => t('Are you sure you want to un-delete this status?'),
    'unflag_message' => '',
    'show_on_page' => FALSE,
    'show_on_teaser' => FALSE,
    'show_on_form' => FALSE,
    'status' => FALSE,
    'link_type' => 'confirm',
    'locked' => array('name', 'global', 'types', 'show_on_page', 'show_on_teaser', 'show_on_form', 'status', 'link_type'),
  );
  return $flags;
}

/**
 * We have to check to make sure class flag_flag exists or we will get a WSOD.
 * The flag_flag class exists if the Flag module is loaded before this file is.
 * The Flag module is loaded first if the weight is higher in the {system} table,
 * and the 'facebook_status_flag_update' variable tells us if this is true.
 */
if (module_exists('flag') && variable_get('facebook_status_flag_update', FALSE)) {
  /**
   * Adds a new flag type.
   * This is here because the Flag module does not support magic include files.
   */
  class facebook_status_flag extends flag_flag {
    function _load_content($content_id) {
      return is_numeric($content_id) ? facebook_status_load($content_id) : NULL;
    }
    function applies_to_content_object($status) {
      //Check for status_time == 0 so we don't flag blank statuses.
      if ($status && $status->status_time) {
        return TRUE;
      }
      return FALSE;
    }
    function get_content_id($status) {
      return $status->sid;
    }
    function get_labels_token_types() {
      return array('facebook_status');
    }
    function get_views_info() {
      return array(
        'views table' => 'facebook_status',
        'join field' => 'uid',
        'title field' => 'status',
        'title' => t('Facebook-style Status'),
        'help' => t('Display information about the flag set on a status.'),
      );
    }
    function applies_to_content_id_array($content_ids) {
      foreach ($content_ids as $content_id) {
        $passed[$content_id] = TRUE;
      }
      return $passed;
    }
    function get_relevant_action_objects($content_id) {
      return array(
        'facebook_status' => $this->fetch_content($content_id),
      );
    }
    function replace_tokens($label, $contexts, $content_id) {
      if ($content_id && ($status = $this->fetch_content($content_id))) {
        $contexts['facebook_status'] = $status;
      }
      return parent::replace_tokens($label, $contexts, $content_id);
    }
    function get_flag_action($content_id) {
      $flag_action = parent::get_flag_action($content_id);
      $status = $this->fetch_content($content_id);
      $flag_action->content_title = $status->status;
      $flag_action->content_url = _flag_url('user/'. $status->uid);
      return $flag_action;
    }
    function rules_get_event_arguments_definition() {
      return array(
        'account' => array(
          'type' => 'facebook_status',
          'label' => t('Flagged status'),
          'handler' => 'flag_rules_get_event_argument',
        ),
      );
    }
    function rules_get_element_argument_definition() {
      return array('type' => 'facebook_status', 'label' => t('Flagged status'));
    }
  }
}